<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Matrix Binary Visualizer + Lyrics Enhanced</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff;font-family:'Courier New',monospace;cursor:crosshair;}
#controls{
  position:absolute; top:10px; left:10px; width:320px; background:rgba(0,0,0,0.92); 
  padding:12px; border-radius:8px; border:2px solid #00ff41;
  display:flex; flex-direction:column; gap:8px; font-size:13px; z-index:1000; 
  transition: transform 0.4s cubic-bezier(0.4,0,0.2,1);
  box-shadow: 0 0 20px rgba(0,255,65,0.3);
  backdrop-filter: blur(5px);
}
#controls.minimized{transform: translateX(-290px);}
#controls .section{
  border-bottom:1px solid #333; padding-bottom:8px; margin-bottom:8px;
}
#controls .section:last-child{border-bottom:none; margin-bottom:0;}
#controls .section-title{
  color:#00ff41; font-weight:bold; margin-bottom:6px; text-transform:uppercase; font-size:12px;
}
#controls label{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;}
#controls input, #controls select, #controls button, #controls textarea{
  width:100%;margin-top:2px;background:#111;color:#fff;border:1px solid #444;
  padding:6px;border-radius:4px;font-family:'Courier New',monospace;font-size:12px;
  transition:all 0.2s;
}
#controls input:focus, #controls select:focus, #controls textarea:focus{
  border-color:#00ff41; box-shadow:0 0 5px rgba(0,255,65,0.3);
}
#controls button{
  background:#222; cursor:pointer; text-align:center;
}
#controls button:hover{background:#333; border-color:#555;}
#controls button.active{background:#004400; border-color:#00ff41; color:#00ff41;}
#controls button.danger{background:#440000; border-color:#ff4444; color:#ff4444;}
canvas{display:block;margin:0 auto;background:#000;}
#keybinds{
  position:absolute; bottom:10px; left:10px; right:10px;
  color:#666; font-size:11px; text-align:center; 
  background:rgba(0,0,0,0.8); padding:8px; border-radius:6px;
  border:1px solid #333;
}
.button-group{display:flex; gap:4px;}
.button-group button{flex:1;}
.range-display{color:#00ff41; font-weight:bold; min-width:35px; text-align:right;}
#performanceMode{
  background:#1a1a1a; color:#00ff41; border:1px solid #00ff41;
}
.status-indicator{
  display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px;
  background:#666;
}
.status-indicator.active{background:#00ff41; box-shadow:0 0 6px #00ff41;}
.status-indicator.error{background:#ff4444; box-shadow:0 0 6px #ff4444;}
</style>
</head>
<body>
<div id="controls">
  <div class="section">
    <button id="toggleUIBtn" style="background:#333; border:1px solid #666;">‚óÄ Minimize Panel</button>
  </div>

  <div class="section">
    <div class="section-title">üéµ Audio Controls</div>
    <div class="button-group">
      <button id="audioBtn">üìÅ Load MP3</button>
      <button id="micBtn">üé§ Microphone</button>
    </div>
    <input type="file" id="audioFile" accept="audio/*" style="display:none">
    <div class="button-group">
      <button id="startAudioBtn">‚ñ∂ Play</button>
      <button id="stopAudioBtn">‚èπ Stop</button>
      <button id="unloadAudioBtn" class="danger">üßπ Clear</button>
    </div>
    <div style="font-size:11px; color:#888; margin-top:4px;">
      <span class="status-indicator" id="audioStatus"></span>
      <span id="audioStatusText">No audio loaded</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">‚ö° Performance Mode</div>
    <select id="performanceMode">
      <option value="stable">üêå Stable (Potato PC)</option>
      <option value="subtle">üî• Subtle Flickers</option>
      <option value="matrix" selected>‚ö° Matrix Rain Style</option>
      <option value="chaos">üíÄ Chaos Mode</option>
    </select>
  </div>

  <div class="section">
    <div class="section-title">üî¢ Binary Background</div>
    <label>Digit Size: <span class="range-display" id="digitSizeDisplay">12</span>px</label>
    <input type="range" id="digitSize" min="6" max="28" value="12">
    <button id="invertNowBtn">üîÑ Invert Colors</button>
    <label>Custom Hotkey: <input type="text" id="hotkeyInput" maxlength="1" style="width:40px; text-align:center; text-transform:uppercase;"></label>
  </div>

  <div class="section">
    <div class="section-title">üìä Visualizer</div>
    <label>Bar Density: <span class="range-display" id="visDensityDisplay">6</span></label>
    <input type="range" id="visDensity" min="2" max="16" value="6">
    <label>Sensitivity: <span class="range-display" id="sensitivityDisplay">1.0</span>x</label>
    <input type="range" id="sensitivity" min="0.5" max="3.0" step="0.1" value="1.0">
  </div>

  <div class="section">
    <div class="section-title">üé§ Lyrics System</div>
    <textarea id="lyricsBox" placeholder="Paste lyrics here, one line per row..." style="height:60px; resize:vertical;"></textarea>
    <label>Duration per line: <span class="range-display" id="durationDisplay">2.0</span>s</label>
    <input type="range" id="lyricDuration" min="0.5" max="10" step="0.1" value="2.0">
    <div class="button-group">
      <button id="loadLyricsBtn">üì• Load</button>
      <button id="startLyricsBtn">‚ñ∂ Start</button>
      <button id="stopLyricsBtn">‚èπ Stop</button>
    </div>
    <button id="unloadLyricsBtn" class="danger">üßπ Clear Lyrics</button>
    <label>Font Family:
      <select id="lyricFontSelect">
        <option>Courier New</option><option>monospace</option><option>Arial</option>
        <option>Times New Roman</option><option>Impact</option><option>Comic Sans MS</option>
      </select>
    </label>
    <div class="button-group">
      <button id="toggleBinaryLyrics">01 Binary</button>
      <button id="toggleGlitch">‚ö° Glitch</button>
    </div>
    <div style="font-size:11px; color:#888; margin-top:4px;">
      <span class="status-indicator" id="lyricsStatus"></span>
      <span id="lyricsStatusText">No lyrics loaded</span>
    </div>
  </div>
</div>

<canvas id="canvas" width="1920" height="1080"></canvas>

<div id="keybinds">
  <strong>HOTKEYS:</strong> 
  [Custom Key] Invert ‚Ä¢ [G] Toggle Glitch ‚Ä¢ [B] Binary Lyrics ‚Ä¢ [L] Start/Stop Lyrics ‚Ä¢ [A] Play Audio ‚Ä¢ [S] Stop Audio ‚Ä¢ [M] Microphone ‚Ä¢ [SPACE] Pause/Resume
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// UI Elements
const audioBtn = document.getElementById('audioBtn');
const micBtn = document.getElementById('micBtn');
const audioFileInput = document.getElementById('audioFile');
const startAudioBtn = document.getElementById('startAudioBtn');
const stopAudioBtn = document.getElementById('stopAudioBtn');
const unloadAudioBtn = document.getElementById('unloadAudioBtn');
const audioStatus = document.getElementById('audioStatus');
const audioStatusText = document.getElementById('audioStatusText');

const performanceModeSelect = document.getElementById('performanceMode');
const digitSizeInput = document.getElementById('digitSize');
const digitSizeDisplay = document.getElementById('digitSizeDisplay');
const visDensityInput = document.getElementById('visDensity');
const visDensityDisplay = document.getElementById('visDensityDisplay');
const sensitivityInput = document.getElementById('sensitivity');
const sensitivityDisplay = document.getElementById('sensitivityDisplay');
const invertNowBtn = document.getElementById('invertNowBtn');
const hotkeyInput = document.getElementById('hotkeyInput');

const lyricsBox = document.getElementById('lyricsBox');
const loadLyricsBtn = document.getElementById('loadLyricsBtn');
const startLyricsBtn = document.getElementById('startLyricsBtn');
const stopLyricsBtn = document.getElementById('stopLyricsBtn');
const unloadLyricsBtn = document.getElementById('unloadLyricsBtn');
const lyricDurationInput = document.getElementById('lyricDuration');
const durationDisplay = document.getElementById('durationDisplay');
const lyricFontSelect = document.getElementById('lyricFontSelect');
const toggleBinaryLyricsBtn = document.getElementById('toggleBinaryLyrics');
const toggleGlitchBtn = document.getElementById('toggleGlitch');
const lyricsStatus = document.getElementById('lyricsStatus');
const lyricsStatusText = document.getElementById('lyricsStatusText');
const toggleUIBtn = document.getElementById('toggleUIBtn');

// Resize canvas to full screen
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  resizeGrid();
}

// Global variables
let digitSize = Number(digitSizeInput.value);
let cols = Math.floor(canvas.width / digitSize);
let rows = Math.floor(canvas.height / digitSize);
let grid = createGrid(rows, cols);
let rainColumns = []; // For Matrix rain effect

// Performance and animation variables
let performanceMode = 'matrix';
let animationPaused = false;

// Canvas optimization
const tileCanvas = document.createElement('canvas');
const tileCtx = tileCanvas.getContext('2d');
tileCanvas.width = digitSize;
tileCanvas.height = digitSize;

// Audio variables
let audioCtx = null;
let analyser = null;
let audioSource = null;
let audioBuffer = null;
let dataArray = null;
let visActive = false;
let micStream = null;
let micActive = false;

// Lyrics variables
let lyrics = [];
let lyricsActive = false;
let currentLine = 0;
let lyricInterval = null;
let binaryLyrics = false;
let glitch = false;

// Visual variables
let hotkey = '';
let invertedVisual = false;

// Matrix rain initialization
function initRainColumns() {
  rainColumns = [];
  for (let i = 0; i < cols; i++) {
    rainColumns[i] = {
      y: Math.random() * rows,
      speed: 0.05 + Math.random() * 0.15,
      chars: []
    };
    // Initialize falling characters for each column
    for (let j = 0; j < 15; j++) {
      rainColumns[i].chars[j] = {
        char: Math.random() > 0.5 ? '1' : '0',
        brightness: Math.max(0, 1 - (j / 8))
      };
    }
  }
}

function createGrid(r, c) {
  const g = new Array(r);
  for (let i = 0; i < r; i++) {
    g[i] = new Uint8Array(c);
    for (let j = 0; j < c; j++) {
      g[i][j] = Math.random() > 0.5 ? 1 : 0;
    }
  }
  return g;
}

function resizeGrid() {
  digitSize = Number(digitSizeInput.value);
  cols = Math.max(4, Math.floor(canvas.width / digitSize));
  rows = Math.max(4, Math.floor(canvas.height / digitSize));
  grid = createGrid(rows, cols);
  initRainColumns();
  
  tileCanvas.width = digitSize;
  tileCanvas.height = digitSize;
  updateTileCanvas();
}

function updateTileCanvas() {
  tileCtx.clearRect(0, 0, digitSize, digitSize);
  tileCtx.fillStyle = invertedVisual ? 'black' : 'white';
  tileCtx.font = `${Math.max(6, digitSize - 2)}px Courier New`;
  tileCtx.textAlign = 'center';
  tileCtx.textBaseline = 'middle';
  tileCtx.fillText('1', digitSize / 2, digitSize / 2);
}

function stepGridNoise() {
  const mode = performanceModeSelect.value;
  
  switch (mode) {
    case 'stable':
      // Very minimal changes - 0.5% chance
      for (let r = 0; r < rows; r += 4) {
        for (let c = 0; c < cols; c += 4) {
          if (Math.random() < 0.005) {
            grid[r][c] = Math.random() > 0.5 ? 1 : 0;
          }
        }
      }
      break;
      
    case 'subtle':
      // Small random flickers - 2% chance
      for (let i = 0; i < Math.min(50, rows * cols * 0.02); i++) {
        const r = Math.floor(Math.random() * rows);
        const c = Math.floor(Math.random() * cols);
        grid[r][c] = Math.random() > 0.5 ? 1 : 0;
      }
      break;
      
    case 'matrix':
      // Matrix rain style with falling columns
      updateMatrixRain();
      break;
      
    case 'chaos':
      // High chaos mode - 8% chance
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (Math.random() < 0.08) {
            grid[r][c] = Math.random() > 0.5 ? 1 : 0;
          }
        }
      }
      break;
  }
}

function updateMatrixRain() {
  // Clear grid first for matrix effect
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      grid[r][c] = 0;
    }
  }
  
  // Update each rain column
  for (let i = 0; i < rainColumns.length; i++) {
    const column = rainColumns[i];
    
    // Move the column down
    column.y += column.speed;
    
    // Reset if off screen
    if (column.y > rows + 15) {
      column.y = -15;
      column.speed = 0.05 + Math.random() * 0.15;
    }
    
    // Draw the falling characters
    for (let j = 0; j < column.chars.length; j++) {
      const charY = Math.floor(column.y - j);
      if (charY >= 0 && charY < rows) {
        grid[charY][i] = 1;
        
        // Randomly change characters
        if (Math.random() < 0.1) {
          column.chars[j].char = Math.random() > 0.5 ? '1' : '0';
        }
      }
    }
  }
}

function drawBackground() {
  ctx.fillStyle = invertedVisual ? 'white' : 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Matrix rain special rendering
  if (performanceModeSelect.value === 'matrix') {
    drawMatrixRain();
  } else {
    // Standard grid rendering
    ctx.fillStyle = invertedVisual ? 'black' : 'white';
    ctx.font = `${Math.max(6, digitSize - 2)}px Courier New`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (grid[r][c]) {
          const char = Math.random() > 0.5 ? '1' : '0';
          ctx.fillText(char, c * digitSize + digitSize/2, r * digitSize + digitSize/2);
        }
      }
    }
  }
}

function drawMatrixRain() {
  ctx.font = `${Math.max(6, digitSize - 2)}px Courier New`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for (let i = 0; i < rainColumns.length; i++) {
    const column = rainColumns[i];
    
    for (let j = 0; j < column.chars.length; j++) {
      const charY = Math.floor(column.y - j);
      if (charY >= 0 && charY < rows) {
        const brightness = Math.max(0, column.chars[j].brightness - (j * 0.1));
        const alpha = Math.min(1, brightness);
        
        if (j === 0) {
          // Head of the rain - bright white/black
          ctx.fillStyle = invertedVisual ? 
            `rgba(0, 0, 0, ${alpha})` : 
            `rgba(255, 255, 255, ${alpha})`;
        } else {
          // Tail - green matrix color
          const greenIntensity = Math.floor(255 * alpha);
          ctx.fillStyle = invertedVisual ? 
            `rgba(${255-greenIntensity}, ${255-Math.floor(greenIntensity*0.8)}, ${255-greenIntensity}, ${alpha})` :
            `rgba(0, ${greenIntensity}, ${Math.floor(greenIntensity*0.3)}, ${alpha})`;
        }
        
        ctx.fillText(
          column.chars[j].char,
          i * digitSize + digitSize/2,
          charY * digitSize + digitSize/2
        );
      }
    }
  }
}

function drawVisualizer() {
  if (!visActive || !analyser) return;
  
  analyser.getByteFrequencyData(dataArray);
  const bins = dataArray.length;
  const density = Number(visDensityInput.value);
  const sensitivity = Number(sensitivityInput.value);
  const barWidth = Math.max(2, Math.round(density));
  const centerX = canvas.width / 2;
  const maxH = canvas.height * 0.6;
  
  ctx.fillStyle = invertedVisual ? 'cyan' : 'red';
  ctx.font = `${Math.max(8, digitSize)}px Courier New`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  const step = Math.floor(digitSize * 0.8);
  const barsToShow = Math.min(bins, Math.floor(canvas.width / (barWidth * 2)));
  
  for (let i = 0; i < barsToShow; i++) {
    const dataIndex = Math.floor((i / barsToShow) * bins);
    const v = (dataArray[dataIndex] / 255) * sensitivity;
    const barH = Math.max(digitSize, v * maxH);
    const leftX = centerX - (i * barWidth) - barWidth;
    const rightX = centerX + (i * barWidth) + barWidth;
    
    // Draw left and right bars with "0" characters
    for (let y = 0; y < barH; y += step) {
      const drawY = canvas.height - y - step/2;
      if (drawY > 0) {
        ctx.fillText('0', leftX, drawY);
        ctx.fillText('0', rightX, drawY);
      }
    }
  }
}

function drawLyrics() {
  if (!lyricsActive || lyrics.length === 0 || currentLine >= lyrics.length) return;
  
  let line = lyrics[currentLine];
  if (binaryLyrics) line = convertToBinary(line);
  if (glitch) {
    line = line.split('').map(c => 
      Math.random() < 0.15 ? 
      String.fromCharCode(33 + Math.floor(Math.random() * 94)) : c
    ).join('');
  }
  
  ctx.fillStyle = invertedVisual ? 'magenta' : 'cyan';
  ctx.font = `28px ${lyricFontSelect.value}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.strokeStyle = invertedVisual ? 'white' : 'black';
  ctx.lineWidth = 2;
  
  const y = 40;
  ctx.strokeText(line, canvas.width / 2, y);
  ctx.fillText(line, canvas.width / 2, y);
}

function convertToBinary(str) {
  return str.split('').map(c => 
    c.charCodeAt(0).toString(2).padStart(8, '0')
  ).join(' ');
}

function render() {
  if (!animationPaused) {
    stepGridNoise();
    drawBackground();
    drawVisualizer();
    drawLyrics();
  }
  requestAnimationFrame(render);
}

// Audio Management
function updateAudioStatus(status, isActive = false, isError = false) {
  audioStatusText.textContent = status;
  audioStatus.className = 'status-indicator' + 
    (isError ? ' error' : isActive ? ' active' : '');
}

function updateLyricsStatus(status, isActive = false) {
  lyricsStatusText.textContent = status;
  lyricsStatus.className = 'status-indicator' + (isActive ? ' active' : '');
}

audioBtn.addEventListener('click', () => audioFileInput.click());

audioFileInput.addEventListener('change', async e => {
  const f = e.target.files[0];
  if (!f) return;
  
  try {
    updateAudioStatus('Loading audio...', false);
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const arr = await f.arrayBuffer();
    audioCtx.decodeAudioData(arr, buf => {
      audioBuffer = buf;
      updateAudioStatus(`Loaded: ${f.name}`, true);
    }, err => {
      updateAudioStatus('Error loading audio', false, true);
    });
  } catch (err) {
    updateAudioStatus('Error loading audio', false, true);
  }
});

// Microphone support
micBtn.addEventListener('click', async () => {
  if (micActive) {
    // Stop microphone
    if (micStream) {
      micStream.getTracks().forEach(track => track.stop());
      micStream = null;
    }
    micActive = false;
    visActive = false;
    updateAudioStatus('Microphone stopped');
    micBtn.classList.remove('active');
    return;
  }
  
  try {
    updateAudioStatus('Requesting microphone access...');
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioCtx.createMediaStreamSource(micStream);
    
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    source.connect(analyser);
    
    micActive = true;
    visActive = true;
    updateAudioStatus('Microphone active', true);
    micBtn.classList.add('active');
  } catch (err) {
    updateAudioStatus('Microphone access denied', false, true);
    console.error('Microphone error:', err);
  }
});

startAudioBtn.addEventListener('click', async () => {
  if (!audioBuffer || !audioCtx) return;
  if (visActive) return;
  
  try {
    if (audioCtx.state === 'suspended') {
      await audioCtx.resume();
    }
    
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    audioSource.connect(analyser);
    analyser.connect(audioCtx.destination);
    
    audioSource.onended = () => {
      visActive = false;
      updateAudioStatus('Playback ended');
      startAudioBtn.classList.remove('active');
    };
    
    audioSource.start();
    visActive = true;
    updateAudioStatus('Playing audio', true);
    startAudioBtn.classList.add('active');
  } catch (err) {
    updateAudioStatus('Playback error', false, true);
  }
});

stopAudioBtn.addEventListener('click', () => {
  if (audioSource) {
    try { audioSource.stop(); } catch {}
    audioSource.disconnect();
    audioSource = null;
  }
  visActive = false;
  updateAudioStatus('Stopped');
  startAudioBtn.classList.remove('active');
});

unloadAudioBtn.addEventListener('click', () => {
  if (audioSource) {
    try { audioSource.stop(); } catch {}
    audioSource.disconnect();
    audioSource = null;
  }
  if (micStream) {
    micStream.getTracks().forEach(track => track.stop());
    micStream = null;
  }
  audioBuffer = null;
  analyser = null;
  dataArray = null;
  visActive = false;
  micActive = false;
  audioFileInput.value = '';
  updateAudioStatus('No audio loaded');
  startAudioBtn.classList.remove('active');
  micBtn.classList.remove('active');
});

// Grid Controls
invertNowBtn.addEventListener('click', flipGrid);
hotkeyInput.addEventListener('input', e => {
  hotkey = e.target.value.toLowerCase();
  e.target.value = e.target.value.toUpperCase();
});

function flipGrid() {
  invertedVisual = !invertedVisual;
  updateTileCanvas();
  invertNowBtn.classList.toggle('active', invertedVisual);
}

// Keyboard Controls
window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  const key = e.key.toLowerCase();
  
  if (hotkey && key === hotkey) flipGrid();
  if (key === 'g') {
    glitch = !glitch;
    toggleGlitchBtn.classList.toggle('active', glitch);
  }
  if (key === 'b') {
    binaryLyrics = !binaryLyrics;
    toggleBinaryLyricsBtn.classList.toggle('active', binaryLyrics);
  }
  if (key === 'l') {
    if (lyricsActive) {
      stopLyricsBtn.click();
    } else {
      startLyricsBtn.click();
    }
  }
  if (key === 'a') startAudioBtn.click();
  if (key === 's') stopAudioBtn.click();
  if (key === 'm') micBtn.click();
  if (key === ' ') {
    e.preventDefault();
    animationPaused = !animationPaused;
  }
});

// Lyrics Controls
loadLyricsBtn.addEventListener('click', () => {
  lyrics = lyricsBox.value.split(/\r?\n/).filter(s => s.trim() !== '');
  currentLine = 0;
  if (lyrics.length > 0) {
    updateLyricsStatus(`${lyrics.length} lines loaded`);
  } else {
    updateLyricsStatus('No lyrics to load');
  }
});

startLyricsBtn.addEventListener('click', () => {
  if (lyrics.length === 0) {
    loadLyricsBtn.click();
    if (lyrics.length === 0) return;
  }
  
  lyricsActive = true;
  currentLine = 0;
  
  if (lyricInterval) clearInterval(lyricInterval);
  
  const durationMs = parseFloat(lyricDurationInput.value) * 1000;
  lyricInterval = setInterval(() => {
    currentLine++;
    if (currentLine >= lyrics.length) {
      stopLyricsBtn.click();
    }
  }, durationMs);
  
  updateLyricsStatus('Lyrics playing', true);
  startLyricsBtn.classList.add('active');
});

stopLyricsBtn.addEventListener('click', () => {
  lyricsActive = false;
  if (lyricInterval) {
    clearInterval(lyricInterval);
    lyricInterval = null;
  }
  updateLyricsStatus(`${lyrics.length} lines loaded`);
  startLyricsBtn.classList.remove('active');
});

unloadLyricsBtn.addEventListener('click', () => {
  lyricsActive = false;
  lyrics = [];
  currentLine = 0;
  lyricsBox.value = '';
  if (lyricInterval) {
    clearInterval(lyricInterval);
    lyricInterval = null;
  }
  updateLyricsStatus('No lyrics loaded');
  startLyricsBtn.classList.remove('active');
});

toggleBinaryLyricsBtn.addEventListener('click', () => {
  binaryLyrics = !binaryLyrics;
  toggleBinaryLyricsBtn.classList.toggle('active', binaryLyrics);
});

toggleGlitchBtn.addEventListener('click', () => {
  glitch = !glitch;
  toggleGlitchBtn.classList.